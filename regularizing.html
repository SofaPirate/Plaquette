<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Regularizing Signals &mdash; Plaquette 0.8.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/plaquette-favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Managing Events" href="events.html" />
    <link rel="prev" title="Working with Time" href="timing_basics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Plaquette
            <img src="_static/Plaquette-LogoText.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.8
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Essentials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="why_plaquette.html">Why Plaquette?</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://raw.githubusercontent.com/SofaPirate/Plaquette/master/extras/Plaquette-Manual.pdf">PDF manual</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs_outputs.html">Inputs and Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="waves.html">Generating Waveforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="timing_basics.html">Working with Time</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Regularizing Signals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#direct-input-to-output">Direct Input-to-Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-the-full-range-of-a-signal">Getting the Full Range of a Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#handling-noisy-or-unpredictable-signals">Handling Noisy or Unpredictable Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reacting-to-signal-changes">Reacting to Signal Changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adapting-to-changing-conditions">Adapting to Changing Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#normalizing-signals-to-spot-extreme-values">Normalizing Signals to Spot Extreme Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choosing-the-right-regularizer-for-the-job">Choosing the Right Regularizer for the Job</a></li>
<li class="toctree-l2"><a class="reference internal" href="#detecting-peaks">Detecting Peaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="events.html">Managing Events</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="base_units.html">Base Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="generators.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="timing.html">Timing</a></li>
<li class="toctree-l1"><a class="reference internal" href="filters.html">Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="fields.html">Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure.html">Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="extra.html">Extra</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/SofaPirate/PqLEDStrip/">PqLEDStrip</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Related Info</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/SofaPirate/Plaquette/">GitHub repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="community.html">Community Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference external" href="http://plaquette.org/doxygen/">Doxygen Documentation</a></li>
<li class="toctree-l1"><a class="reference external" href="https://joss.theoj.org/papers/10.21105/joss.09144">JOSS paper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plaquette</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Regularizing Signals</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="regularizing-signals">
<h1>Regularizing Signals<a class="headerlink" href="#regularizing-signals" title="Permalink to this heading"></a></h1>
<p>Plaquette provides expressive, automated, and robust ways to deal with signals
for interactive design using <strong>regularization filters</strong> such as smoothing,
min-max scaling, and normalization.</p>
<section id="direct-input-to-output">
<h2>Direct Input-to-Output<a class="headerlink" href="#direct-input-to-output" title="Permalink to this heading"></a></h2>
<p>Let’s review briefly how to handle raw <a class="reference internal" href="inputs_outputs.html"><span class="doc">input and output</span></a> signals in Plaquette.
We will be using an analog sensor such as a photoresistor for this example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to build this circuit, you will need to create a simple
<a class="reference external" href="https://learn.sparkfun.com/tutorials/voltage-dividers">voltage divider circuit</a>.
Connect the photoresistor between the ground (GND) and the analog input pin (<code class="docutils literal notranslate"><span class="pre">A0</span></code>). Then connect
a fixed resistor with value matching your photoresistor between analog input pin and +5V (Vcc).
For example, for a 1k <span class="math notranslate nohighlight">\(\Omega\)</span> - 10k <span class="math notranslate nohighlight">\(\Omega\)</span> photoresistor you could use a fixed
resistor of about 5.5k <span class="math notranslate nohighlight">\(\Omega\)</span>).</p>
<img alt="_images/Plaquette-CircuitVoltageDivider.png" class="align-center" src="_images/Plaquette-CircuitVoltageDivider.png" />
</div>
<p>Here is a basic Arduino sketch that allows changing the value of an output LED using an input photocell:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The photocell analog pin.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">photoCellPin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// The output analog LED pin.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ledPin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Initialize pins.</span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="n">photoCellPin</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">pinMode</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Read value from photocell (between 0 and 1023).</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">analogRead</span><span class="p">(</span><span class="n">photoCellPin</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Write value to LED (between 0 and 255).</span>
<span class="w">  </span><span class="n">analogWrite</span><span class="p">(</span><span class="n">ledPin</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As explained in <a class="reference internal" href="why_plaquette.html"><span class="doc">Why Plaquette?</span></a> section, this code forces the programmer needs to
remember low-level information concerning the ranges of raw number values (1023, 255, …)
Furthermore, it fails to adapt to changing conditions such as the range of the ambient light,
which might evolve over the course of the day.</p>
<p>Let’s see how Plaquette can help us to create more expressive code by using inputs and
outputs signals rather than meaningless raw numbers.</p>
<p>To begin, we will re-implement the example above using Plaquette units.</p>
<p>First, let’s define our input photocell on pin <code class="docutils literal notranslate"><span class="pre">A0</span></code> using an <a class="reference internal" href="AnalogIn.html"><span class="doc">AnalogIn</span></a> unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AnalogIn</span><span class="w"> </span><span class="nf">photoCell</span><span class="p">(</span><span class="n">A0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Then, let’s add an output analog LED on pin <cite>9</cite> using an <a class="reference internal" href="AnalogOut.html"><span class="doc">AnalogOut</span></a> unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AnalogOut</span><span class="w"> </span><span class="nf">led</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>If we want to directly control the value of the LED from the value of the
photocell, all we need to do is to send the photocell’s value to the led. The
easiest way to do so is by using the <a class="reference internal" href="pipe.html"><span class="doc">&gt;&gt;</span></a> operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The complete Plaquette code looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Plaquette.h&gt;</span><span class="c1"> // include the Plaquette library</span><span class="cp"></span>

<span class="c1">// Create input unit for photocell.</span>
<span class="n">AnalogIn</span><span class="w"> </span><span class="nf">photoCell</span><span class="p">(</span><span class="n">A0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create output unit for LED.</span>
<span class="n">AnalogOut</span><span class="w"> </span><span class="nf">led</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// Define frame-by-frame operations.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Send photocell value directly to the LED.</span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="getting-the-full-range-of-a-signal">
<h2>Getting the Full Range of a Signal<a class="headerlink" href="#getting-the-full-range-of-a-signal" title="Permalink to this heading"></a></h2>
<p>If we run this program, we will likely notice that the LED brightness will not
span the full range from 0% to 100%. That’s because depending on ambient lighting
conditions, the photocell’s values will not move across the full spectrum of
possibility. For instance, in the dark, the photocell might range from 10% to 50%,
while in full daylight, it might range between 70% and 95%.</p>
<p>In order to resolve this issue, we need to <strong>regularize</strong> the photocell’s signal.
We can do so using a filtering unit such as a <a class="reference internal" href="MinMaxScaler.html"><span class="doc">MinMaxScaler</span></a>. This unit automatically
keeps track of the minimum and maximum values of the incoming signal over time
(for example, 10% and 50%) and remaps them into a new interval of [0, 1] (ie., 0% to 100%).</p>
<img alt="_images/Plaquette-MinMaxScaler.png" src="_images/Plaquette-MinMaxScaler.png" />
<p>To use this approach, create the unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MinMaxScaler</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>… and then <em>insert it</em> in the pipeline between the incoming photocell signal and
the output LED:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The above expression will do the following, in order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Read the raw photocell value using the <code class="docutils literal notranslate"><span class="pre">photoCell</span></code> unit.</p></li>
<li><p>Send that raw value from the <code class="docutils literal notranslate"><span class="pre">photoCell</span></code> unit to the <code class="docutils literal notranslate"><span class="pre">regularizer</span></code> unit.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">regularizer</span></code> unit updates itself if the value is a new extreme value (minimum or maximum).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">regularizer</span></code> then remaps the raw photocell value to the full range of [0, 1] and sends it to the <code class="docutils literal notranslate"><span class="pre">led</span></code> unit.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">led</span></code> unit takes the input value in [0, 1] and applies it to the intensity of the LED.</p></li>
</ol>
</div></blockquote>
</section>
<section id="handling-noisy-or-unpredictable-signals">
<h2>Handling Noisy or Unpredictable Signals<a class="headerlink" href="#handling-noisy-or-unpredictable-signals" title="Permalink to this heading"></a></h2>
<p>The <a class="reference internal" href="MinMaxScaler.html"><span class="doc">MinMaxScaler</span></a> is great when your signal behaves in a fairly stable way. It
learns the smallest and largest values it has ever seen, then stretches everything
into a clean [0, 1] range. However, some sensors behave in a much more irregular way.
They might produce short spikes, sudden jumps, or occasional “glitches.” These rare
events can throw off the MinMaxScaler by forcing it to update its minimum or maximum
too aggressively.</p>
<p>For such situations, Plaquette provides the <a class="reference internal" href="RobustScaler.html"><span class="doc">RobustScaler</span></a>. Instead of focusing
on <em>extreme</em> values, the RobustScaler concentrates on what the signal is doing <em>most
of the time</em>. It keeps track of a “typical low” and a “typical high” value, ignoring
rare spikes, and maps the signal between 0 and 1 based on this typical span.</p>
<img alt="_images/Plaquette-RobustScaler.png" src="_images/Plaquette-RobustScaler.png" />
<p>You can create a RobustScaler the same way as a MinMaxScaler:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RobustScaler</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Then:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The output still stays within [0, 1], but the regularizer behaves more calmly and is
less affected by sudden unexpected events.</p>
<p>If needed, you can adjust how tolerant it is to spikes by setting its <code class="docutils literal notranslate"><span class="pre">span()</span></code>. A
larger span makes it more robust but also clamps extreme values more strongly. A
smaller span makes it more sensitive but less stable.</p>
</section>
<section id="reacting-to-signal-changes">
<h2>Reacting to Signal Changes<a class="headerlink" href="#reacting-to-signal-changes" title="Permalink to this heading"></a></h2>
<p>Remember our example from <a class="reference internal" href="why_plaquette.html"><span class="doc">ealier</span></a>, where we were trying to detect high-valued
signals using arbitrary numbers?</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">716</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="c1">// do something</span>
</pre></div>
</div>
<p>Suppose that instead of directly controlling the LED value based on the photocell’s
value, we instead want to use sudden changes in the photocell’s value to
trigger the on/off state of the LED? In other words, we would like to work with the <strong>peaks</strong> in the
incoming signal (such as when someone points a light source towards the photocell).</p>
<p>One way to do so would be to pick a threshold in the regularized signal
above which we would react to the light source. Let’s say that we will react
when the signal goes above 70%. The code of the <code class="docutils literal notranslate"><span class="pre">step()</span></code> function now
becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">regularizer</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.7</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="mi">0</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>… which can be more compactly rewritten by sending directly the conditional
expression <code class="docutils literal notranslate"><span class="pre">(regularizer</span> <span class="pre">&gt;</span> <span class="pre">0.7)</span></code> to the output LED:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">regularizer</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.7</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="adapting-to-changing-conditions">
<h2>Adapting to Changing Conditions<a class="headerlink" href="#adapting-to-changing-conditions" title="Permalink to this heading"></a></h2>
<p>So far so good. The number 0.7 is still a bit of an arbitrary, hand-picked number, but it makes
more sense than 716 because it refers to a more human-understandable concept
(70% instead of 716 / 1023). However, this approach will still be sensitive to changes in
the ambient light, and behave differently under different light conditions (for example, it might
work as expected in the morning, but work less well in the late afternoon when the sun starts to go down.)</p>
<p>One thing we could do would be to make sure that our regularization unit adapts
to changing conditions. In order to do this, rather than having our MinMaxScaler
remap values depending on every single incoming value, we can have it
adapt over a <strong>time window</strong>. This will allow our regularizer to slowly forget
what it has learned, and reprogram itself after a certain amount of time has passed.</p>
<p>This can be accomplished by calling the <code class="docutils literal notranslate"><span class="pre">timeWindow(seconds)</span></code> function inside
the <code class="docutils literal notranslate"><span class="pre">begin()</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Allow regularizer to adapt over an approximate period of 1 hour (3600 s).</span>
<span class="w">  </span><span class="n">regularizer</span><span class="p">.</span><span class="n">timeWindow</span><span class="p">(</span><span class="mf">3600.0f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="normalizing-signals-to-spot-extreme-values">
<h2>Normalizing Signals to Spot Extreme Values<a class="headerlink" href="#normalizing-signals-to-spot-extreme-values" title="Permalink to this heading"></a></h2>
<p>The MinMaxScaler is a very useful unit for making sure signals stay within a
[0, 1] range. However, it is not always the best for signal detection since it
only accounts for extreme values (minimum and maximum), which makes it sensitive
to rare events. Someone switching the lights on and off again rapidly might completely
ruin the show.</p>
<p>A better alternative is the <a class="reference internal" href="Normalizer.html"><span class="doc">Normalizer</span></a> unit, which regularizes incoming signals
by normalizing them around a target <strong>mean</strong> by taking into account <strong>standard deviation</strong>.
Once the data is normalized, extreme <strong>outlier</strong> values can be more easily and robustly detected
based on how much they diverge from the mean.</p>
<p>Let’s replace our MinMaxScaler by a Normalizer unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Normalizer</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>… and use the <code class="docutils literal notranslate"><span class="pre">isHighOutlier()</span></code> function to find values that are higher
than usual:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">regularizer</span><span class="p">.</span><span class="n">isHighOutlier</span><span class="p">(</span><span class="n">photoCell</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">isHighOutlier()</span></code> function detects values that are more than
1.5 deviations from the mean. The function can be made more or less sensitive by
adjusting the number of deviations (typically between 1.0 and 3.0). For example,
<code class="docutils literal notranslate"><span class="pre">isHighOutlier(value,</span> <span class="pre">1.2)</span></code> will be more sensitive,
<code class="docutils literal notranslate"><span class="pre">isHighOutlier(value,</span> <span class="pre">2.5)</span></code> will be less sensitive, and <code class="docutils literal notranslate"><span class="pre">isHighOutlier(value,</span> <span class="pre">3.0)</span></code>
will only respond to rarely-occuring extremes. While these numbers (1.2, 1.5, 2.5, etc.)
still need to be hand-picked, they are much more robust than our 716 and even to
our 0.7 number from earlier.</p>
</div>
<p>Here is a complete version of the code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Plaquette.h&gt;</span><span class="c1"> // include the Plaquette library</span><span class="cp"></span>

<span class="c1">// Create input unit for photocell.</span>
<span class="n">AnalogIn</span><span class="w"> </span><span class="nf">photoCell</span><span class="p">(</span><span class="n">A0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create output unit for LED.</span>
<span class="n">AnalogOut</span><span class="w"> </span><span class="nf">led</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create regularization object.</span>
<span class="n">Normalizer</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Initialize everything.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Allow regularizer to adapt over an approximate period of 1 hour (3600 s).</span>
<span class="w">  </span><span class="n">regularizer</span><span class="p">.</span><span class="n">timeWindow</span><span class="p">(</span><span class="mf">3600.0f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Define frame-by-frame operations.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Update regularizer with raw signal value.</span>
<span class="w">  </span><span class="n">photoCell</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">regularizer</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Detect outliers and send the value (1=true=outlier, 0=false=no outlier)</span>
<span class="w">  </span><span class="c1">// directly to the LED.</span>
<span class="w">  </span><span class="n">regularizer</span><span class="p">.</span><span class="n">isHighOutlier</span><span class="p">(</span><span class="n">photoCell</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">led</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="choosing-the-right-regularizer-for-the-job">
<h2>Choosing the Right Regularizer for the Job<a class="headerlink" href="#choosing-the-right-regularizer-for-the-job" title="Permalink to this heading"></a></h2>
<p>In creative media, each regularizer offers a different way of interpreting the same
signal. A simple way to choose between them is to think about the kind of behaviour
you want:</p>
<ul class="simple">
<li><p>Use <strong>MinMaxScaler</strong> when you want to <strong>use the full expressive range</strong> of the
signal exactly as it occurs. It is a good choice when the signal’s lowest and
highest values are <em>meaningful</em> (not accidental glitches), and when you want
outliers to have a noticeable effect. This makes it ideal for direct mappings
where the natural span of the sensor should translate into the full motion of a
parameter such as brightness, speed, position, or size.</p></li>
<li><p>Use <strong>RobustScaler</strong> when you want <strong>stable behaviour</strong> even in the presence of
noise, glitches, or unpredictable input. It focuses on the “typical” range of the
signal and ignores rare spikes, making it suitable for real-world sensors with
variability, jitter, or unpredictable environmental conditions.</p></li>
<li><p>Use <strong>Normalizer</strong> when you want to understand <strong>how far the signal deviates
from its typical behaviour</strong>, rather than how big or small it is in absolute
terms. This is useful for detecting unusual events, bursts of activity, or
expressive gestures that stand out relative to the usual pattern of the sensor.</p></li>
</ul>
<p>Thinking about your signal in terms of <strong>expressive range</strong>, <strong>stability</strong>, or
<strong>deviation</strong> will help you select the regularizer that best supports the
interaction you are designing.</p>
<p>The table below summarizes when and why you would use each unit, and gives examples
of typical signals where each is a good fit.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Regularizer</p></th>
<th class="head"><p>Best Used When …</p></th>
<th class="head"><p>Pros &amp; Cons</p></th>
<th class="head"><p>Example Signals</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="MinMaxScaler.html"><span class="doc">MinMaxScaler</span></a></p></td>
<td><p>Your signal has <strong>clear, stable limits</strong> and you want to remap it
cleanly into the full <strong>[0, 1]</strong> range, often for direct control
(sensor → brightness, speed, position, etc.).</p></td>
<td><p><strong>Pros:</strong></p>
<ul class="simple">
<li><p>Very simple and intuitive</p></li>
<li><p>Great for direct, continuous mappings</p></li>
<li><p>Easy to reason about visually (“full sweep = 0% to 100%”)</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul class="simple">
<li><p>Very sensitive to spikes and rare extreme values (outliers)</p></li>
<li><p>Sudden glitches can distort the usable range</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Photocells in controlled lighting</p></li>
<li><p>Distance sensors with bounded ranges</p></li>
<li><p>Knobs, sliders, faders</p></li>
<li><p>Flex sensors over limited movement arcs</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="RobustScaler.html"><span class="doc">RobustScaler</span></a></p></td>
<td><p>Your signal is <strong>noisy, erratic, or unpredictable</strong>, and you want
a stable result even when rare spikes occur. You care more about
the “typical” range than about extremes.</p></td>
<td><p><strong>Pros:</strong></p>
<ul class="simple">
<li><p>Tolerant to outliers</p></li>
<li><p>Ignores occasional glitches</p></li>
<li><p>Produces a stable [0, 1] range</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">span()</span></code> adjusts robustness vs. sensitivity</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul class="simple">
<li><p>Very extreme values may be clamped</p></li>
<li><p>Adapts more slowly than MinMaxScaler</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Physiological / biosignals (heart-rate, EMG, GSR, EEG amplitude)</p></li>
<li><p>Noisy microphones or piezo discs</p></li>
<li><p>Jittery accelerometers</p></li>
<li><p>Environmental sensors in public spaces</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="Normalizer.html"><span class="doc">Normalizer</span></a></p></td>
<td><p>You want to understand a signal in terms of <strong>how much it differs from its
own average behaviour</strong>. Works best when the signal naturally clusters around
a single central value (a “bell-shaped” or roughly normal distribution).</p></td>
<td><p><strong>Pros:</strong></p>
<ul class="simple">
<li><p>Provides a clear measure of relative deviation from the mean</p></li>
<li><p>Tolerant to outliers</p></li>
<li><p>Very effective for identifying outliers or unusual events</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul class="simple">
<li><p>Output is not limited to [0, 1]</p></li>
<li><p>Less suited for direct sensor → output mappings</p></li>
<li><p>Can be misleading for signals with multiple distinct operating states (e.g., empty room vs. crowded room)</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Photocells where the goal is to detect departures from normal light levels</p></li>
<li><p>Microphones used to detect unusual loudness relative to ambient noise</p></li>
<li><p>Motion sensors where gestures stand out against small baseline movement</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</section>
<section id="detecting-peaks">
<h2>Detecting Peaks<a class="headerlink" href="#detecting-peaks" title="Permalink to this heading"></a></h2>
<p>The outlier detection method is useful to find extreme values. However, it also
comes with an important limitation. The <code class="docutils literal notranslate"><span class="pre">isHighOutlier()</span></code> and <code class="docutils literal notranslate"><span class="pre">isOutlierLow()</span></code>
methods return <code class="docutils literal notranslate"><span class="pre">true</span></code> <em>as long as</em> the received value is considered to be an
outlier, making these methods unsuitable for triggering instantanous events, such as
toggling the status of an LED, starting a sound event, activating a motor, etc.</p>
<p>The <a class="reference internal" href="PeakDetector.html"><span class="doc">PeakDetector</span></a> unit addresses this limitation. It is best used in combination
with a Normalizer unit. We will use the default mode of the PeakDetector (<code class="docutils literal notranslate"><span class="pre">PEAK_MAX</span></code>):
for a peak to be detected. In this mode, the signal will need to (1) cross a <em>trigger threshold</em> value
(<code class="docutils literal notranslate"><span class="pre">triggerThreshold</span></code>); (2) reach its <em>apex</em> (max); and (3) <em>fall back</em> by a certain
proportion (%) between the threshold and the apex (controlled by the <code class="docutils literal notranslate"><span class="pre">fallbackTolerance</span></code>
parameter).</p>
<img alt="_images/Plaquette-PeakDetector.png" src="_images/Plaquette-PeakDetector.png" />
<p>Building on the previous section for outlier detection, we will assign the PeakDetector’s
<code class="docutils literal notranslate"><span class="pre">triggerThreshold</span></code> to the value above which a value is considered to be a high outlier,
which can be obtained by calling the Normalizer’s function <code class="docutils literal notranslate"><span class="pre">highOutlierThreshold()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PeakDetector</span><span class="w"> </span><span class="nf">detector</span><span class="p">(</span><span class="n">normalizer</span><span class="p">.</span><span class="n">highOutlierThreshold</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>As for the <code class="docutils literal notranslate"><span class="pre">isHighOutlier()</span></code> function, the <code class="docutils literal notranslate"><span class="pre">highOutlierThreshold()</span></code> function
is set to return, by default, a threshold that is 1.5 standard deviations from the mean. The
function can be made more or less sensitive by adjusting the number of deviations.
For example, <code class="docutils literal notranslate"><span class="pre">highOutlierThreshold(1.2)</span></code> will be more sensitive, while
<code class="docutils literal notranslate"><span class="pre">highOutlierThreshold(2.5)</span></code> will be less sensitive.</p>
</div>
<p>Finally, let’s rewrite the <code class="docutils literal notranslate"><span class="pre">step()</span></code> function with our new peak detector, so
that only when a <strong>peak</strong> is detected will the LED change state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">step</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Signal is normalized and sent to peak detector.</span>
<span class="w">  </span><span class="n">sensor</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">normalizer</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">detector</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Toggle LED when peak detector triggers.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">detector</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">led</span><span class="p">.</span><span class="n">toggle</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The PeakDetector unit offers many options to fine-tune the peak detection process.
Please read the <a class="reference internal" href="PeakDetector.html"><span class="doc">full documentation of the unit</span></a> for details.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading"></a></h2>
<p>The Plaquette library simplifies signal processing for interactive design by abstracting low-level
details and offering intuitive regularization tools like <a class="reference internal" href="MinMaxScaler.html"><span class="doc">MinMaxScaler</span></a> and <a class="reference internal" href="Normalizer.html"><span class="doc">Normalizer</span></a>.
Combined with <a class="reference internal" href="PeakDetector.html"><span class="doc">PeakDetector</span></a> opens the way to deploy precise event-driven behaviors.</p>
<p>Plaquette’s ability to adapt to changing conditions ensures dynamic, robust systems while keeping code
concise and expressive. By leveraging its modular architecture, users can streamline signal
handling, improve scalability, and focus on innovation in signal-driven creative applications.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="timing_basics.html" class="btn btn-neutral float-left" title="Working with Time" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="events.html" class="btn btn-neutral float-right" title="Managing Events" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, Plaquette.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>